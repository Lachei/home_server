<!DOCTYPE html>

<html>

<head>
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <title>Gpx Editor</title>
    <style>
        html * {
            font-family: Arial, Helvetica, sans-serif;
            font-size: min(2vw, .5cm);
        }

        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0px;
            overflow: hidden;
        }

        body {
            display: table;
        }

        a {
            cursor: pointer;
        }

        button {
            border: none;
            background-color: white;
            cursor: pointer;
        }

        .preview {
            height: 100%;
            width: 100%;
            background-color: black;
        }

        .fill {
            width: 100%;
            height: 100%;
        }

        #header,
        #content {
            display: table-row;
        }

        #header+#content {
            height: 100%;
        }

        #canvas3d {
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="header">
        {{#editor}}
        <center id="title">GPX Editor</center>
        <button id="save" onclick="save();">&#128190;</button>
        <select id="layer_select" onchange="virtual_street_map.drop_least_important_tiles();">
            <option base_url="tile.openstreetmap.org/" ending=".png">OSM</option>
            <option base_url="c.tile-cyclosm.openstreetmap.fr/cyclosm/" ending=".png">CyclOSM</option>
            <option base_url="api.mapbox.com/v4/mapbox.satellite/" ending=".webp?sku=101tnFDhwLDVr&access_token=pk.eyJ1Ijoic3ZjLW9rdGEtbWFwYm94LXN0YWZmLWFjY2VzcyIsImEiOiJjbG5sMnFlZ28wb2d5MnFtb2xnMG90OW96In0.IE8Vqs0NTzCY0WqPzV9kcw">Satellit</option>
            <option base_url="intergeo37.bayernwolke.de/betty/g_atkis3d/" ending="">Stra√üen bayern</option>
            <option base_url="intergeo31.bayernwolke.de/betty/g_satdop40_komplett/" ending="">Satellit bayern</option>
        </select>
        {{/editor}}
    </div>
    <div id="content">
        <div id="preview" class="preview">
            <canvas id="canvas3d" class="fill"></canvas>
        </div>
    </div>
</body>
<script type="text/javascript" src="{{&site_url}}/lin_alg.js"></script>
<script type="text/javascript" src="{{&site_url}}/virtual_texture.js"></script>
<script type="text/javascript" src="{{&site_url}}/pro4.js"></script>
<!--<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js"></script>-->
<script>
    // var spector = new SPECTOR.Spector();
    // spector.displayUI();
    // spector.spyCanvases();

    const user_credentials = "{{credentials}}";
    const file_path = "{{&file_path}}";

    let canvas3d = document.getElementById("canvas3d");
    let canvas_tile_ids_2d_ctx = null;
    let canvas_drag_start = null;
    let camera_state = {};  // contains all camera state for rendering
    let gl_context = null;
    let indices_render_objs = {}; // object containing render objects needed for index rendering
    let render_pipelines = null;
    let camera_center = null;
    const cam_rot_speed = .001;
    const cam_dir_speed = Util.m_to_wgs_84_deg(1); // go forward 1 meter
    const up_dir = Vec4(0, 0, 1, 0);
    let camera_dir = 0;     // given in radians, 0 means dead north
    let camera_pitch = 0;   // given in radians, 0 means straight ahead, pi straight up -pi straight down
    let camera_perspective = null;
    let camera_orthographic = null;
    let camera_interpolation = 0; // interpolation value between orthographic and projection mapping (0 means full projection, 1 means full orthographic)
    let heightmap_meta_data = null;
    let bayernatlas_data = null;
    /** @type {VirtualHeightMap} */
    let virtual_height_map = null;
    let virtual_street_map = null;
    canvas3d.addEventListener("mousedown", (e) => { if (e.buttons == 1) canvas_drag_start = { x: e.screenX, y: e.screenY }; });
    canvas3d.addEventListener("touchstart", (e) => {canvas_drag_start = { x: e.touches[0].screenX, y: e.touches[0].screenY, scale: e.scale}; });
    canvas3d.addEventListener("mousemove", async (event) => {
        if (canvas_drag_start) {
            let xDel = canvas_drag_start.x - event.screenX;
            let yDel = canvas_drag_start.y - event.screenY;
            camera_dir -= xDel * cam_rot_speed;
            if (camera_dir > 2 * Math.PI) camera_dir -= 2 * Math.PI;
            if (camera_dir < 0) camera_dir += 2 * Math.PI;
            camera_pitch += yDel * cam_rot_speed;
            if (camera_pitch > Math.PI / 2) camera_pitch = Math.PI / 2;
            if (camera_pitch < -Math.PI / 2) camera_pitch = -Math.PI / 2;
            await draw_scene();
            canvas_drag_start = { x: event.screenX, y: event.screenY };
        }
    });
    canvas3d.addEventListener("touchmove", async (event) => {
        if (canvas_drag_start) {
            let xDel = canvas_drag_start.x - event.touches[0].screenX;
            let yDel = canvas_drag_start.y - event.touches[0].screenY;
            let sDel = canvas_drag_start.scale - event.scale;
            camera_dir -= xDel * cam_rot_speed * 2;
            if (camera_dir > 2 * Math.PI) camera_dir -= 2 * Math.PI;
            if (camera_dir < 0) camera_dir += 2 * Math.PI;
            camera_pitch += yDel * cam_rot_speed * 2;
            if (camera_pitch > Math.PI / 2) camera_pitch = Math.PI / 2;
            if (camera_pitch < -Math.PI / 2) camera_pitch = -Math.PI / 2;
            if (canvas_drag_start.scale) {
                let height_multiplier = Math.max(1, 0.005 * (Util.wgs_84_ddeg_to_m(camera_center.z()) - 1100));
                camera_center.add(get_forward_dir(camera_dir, camera_pitch).mul(.1 * cam_dir_speed * height_multiplier * sDel));
            }
            await draw_scene();
            canvas_drag_start = { x: event.touches[0].screenX, y: event.touches[0].screenY, scale: event.scale };
            e.preventDefault();
        }
    });
    canvas3d.addEventListener("mouseup", (e) => { canvas_drag_start = null; });
    canvas3d.addEventListener("mouseleave", (e) => { canvas_drag_start = null; });
    canvas3d.addEventListener("touchend", (e) => { canvas_drag_start = null; });
    canvas3d.addEventListener("touchcancel", (e) => { canvas_drag_start = null; });
    canvas3d.addEventListener("wheel", async (e) => {
        let height_multiplier = Math.max(1, 0.005 * (Util.wgs_84_ddeg_to_m(camera_center.z()) - 1100));
        camera_center.add(get_forward_dir(camera_dir, camera_pitch).mul(.1 * cam_dir_speed * height_multiplier * e.deltaY));
        await draw_scene();
    });
    let pressed_keys = {};
    window.addEventListener("keydown", async (e) => {
        if (document.querySelector(".preview:hover") == null)
            return;

        let speed = cam_dir_speed;
        let key = e.key;
        if (key === key.toUpperCase()) {
            key = key.toLowerCase();
            speed *= 100;
        }
        if (key === "w")
            camera_center.add(get_forward_dir(camera_dir, camera_pitch).mul(-speed));
        if (key === "a")
            camera_center.add(get_right_dir(camera_dir).mul(-speed));
        if (key === "s")
            camera_center.add(get_forward_dir(camera_dir, camera_pitch).mul(speed));
        if (key === "d")
            camera_center.add(get_right_dir(camera_dir).mul(speed));
        if (key === "q")
            camera_center.add(up_dir.multiply(-speed));
        if (key === "e")
            camera_center.add(up_dir.multiply(speed));
        e.preventDefault();
        await draw_scene();
    });

    function filter_object(obj, callback) {
        return Object.fromEntries(Object.entries(obj).filter(([key, val]) => callback(key, val)));
    };
    // main function to load the images and update the image information buffer
    let image_cache = {};   // image cache for detail height
    async function update_cached_images() {
        // checking detail image tiles which are available on the self hosted server
        // the detail heights for the 4 closest tiles will always be tried to be kept in memory
        let tiles_to_load = [];
        for (let tile in heightmap_meta_data) {
            // lat are the y coordinates
            let lat_diff = Math.abs(heightmap_meta_data[tile].center_lat - camera_center.y());
            // lon are the x coordinates
            let lon_diff = Math.abs(heightmap_meta_data[tile].center_lon - camera_center.x());
            if (lat_diff + lon_diff <= 1e3)
                tiles_to_load.push(tile);
            if (tiles_to_load.length >= 4)
                break;
        }
        let all_tiles_to_load = tiles_to_load;
        tiles_to_load = tiles_to_load.filter(v => v in image_cache === false)           // only load images that are not yet cached
        if (tiles_to_load.length === 0)
            return;
        console.log("Loading the following tiles");
        console.log(tiles_to_load);
        tiles_to_load.forEach(v => {
            let image = new Image();
            image.onload = () => {
                let texture = gl_context.createTexture();
                gl_context.bindTexture(gl_context.TEXTURE_2D, texture);
                gl_context.texImage2D(gl_context.TEXTURE_2D, 0, gl_context.RGBA, gl_context.RGBA, gl_context.UNSIGNED_BYTE, image);
                gl_context.generateMipmap(gl_context.TEXTURE_2D);
                gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_S, gl_context.CLAMP_TO_EDGE);
                gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_T, gl_context.CLAMP_TO_EDGE);
                gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MIN_FILTER, gl_context.LINEAR_MIPMAP_LINEAR);
                image_cache[v].texture = texture;
                update_gpu_images();
            }
            image.src = location.origin + "/heightmap/" + v + "_h";
            image_cache[v] = { image: image };
        });
        image_cache = filter_object(image_cache, (key, val) => all_tiles_to_load.find(v => key === v) != undefined); // remove unused cached stuff
    }

    // is called by the update_cached images when a new image was loaded
    // the gpu textures are already uploaded, the main thing being updated here is the gpu array information
    // which is then bound for expansion information
    let image_gpu_infos = { textures: [], texture_infos: [] };
    async function update_gpu_images() {
        image_gpu_infos.textures = [];
        image_gpu_infos.texture_infos = [];
        let i = 0;
        for (let image in image_cache) {
            image_gpu_infos.texture_infos.push(i);                                  // texture index
            image_gpu_infos.texture_infos.push(heightmap_meta_data[image].min_lat); // lat min
            image_gpu_infos.texture_infos.push(heightmap_meta_data[image].max_lat); // lat max
            image_gpu_infos.texture_infos.push(heightmap_meta_data[image].min_lon); // lon min
            image_gpu_infos.texture_infos.push(heightmap_meta_data[image].max_lon); // lon max
            image_gpu_infos.texture_infos.push(heightmap_meta_data[image].min);     // height min
            image_gpu_infos.texture_infos.push(heightmap_meta_data[image].max);     // height max
            image_gpu_infos.textures.push(image_cache[image].texture);
            i += 1;
        }

        await draw_scene();
    }

    // draws the scene with all loaded data
    function draw_scene() {
        if (!gl_context)
            return;

        // creating the view matrix -------------------------------------------
        //console.log("Cam dir: " + String(camera_dir) + ", pitch: " + String(camera_pitch));
        let at = get_forward_dir(camera_dir, camera_pitch).to_absolute_vec();
        at.entries[2] += camera_center.z();
        const view = LookAt(Vec4(0, 0, camera_center.z(), 1), // camera_center is always in the center, the tiles a re moved relative to the camera center
            at,
            up_dir);
        let view_projection = camera_perspective.morph(camera_orthographic, camera_interpolation);
        view_projection.mul(view);  // inplace multiplication which corresponds to Proj * View which means the view matrix is applied before the projection

        // drawing the tiles --------------------------------------------------
        const draw_tiles = (gl, fb_size, program, framebuffer) => {
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.viewport(0, 0, fb_size.width, fb_size.height);
            gl.clearColor(1., 1., 1., 1.0);
            gl.clearDepth(1.0);

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.enable(gl.DEPTH_TEST);

            gl.useProgram(program.program);
            // gl.uniform3fv(program.uniform_locations.cam_pos, [camera_center.x(), camera_center.y(), camera_center.z()]);
            gl.uniformMatrix4fv(program.uniform_locations.view_proj, false, view_projection.entries);
            
            // binding the virtual textures
            virtual_height_map.bind_to_shader(gl.TEXTURE0, gl.TEXTURE1, program.uniform_locations.virtual_heightmap_infos);
            gl.uniform1i(program.uniform_locations.virtual_heightmap_index, 0);
            gl.uniform1i(program.uniform_locations.virtual_heightmap, 1);
            gl.uniformBlockBinding(program.program, program.uniform_locations.virtual_heightmap_infos, program.uniform_locations.virtual_heightmap_infos);
            if (program.uniform_locations.virtual_streetmap_infos < 10) {
                virtual_street_map.bind_to_shader(gl.TEXTURE2, gl.TEXTURE3, program.uniform_locations.virtual_streetmap_infos);
                gl.uniform1i(program.uniform_locations.virtual_streetmap_index, 2);
                gl.uniform1i(program.uniform_locations.virtual_streetmap, 3);
                gl.uniformBlockBinding(program.program, program.uniform_locations.virtual_streetmap_infos, program.uniform_locations.virtual_streetmap_infos);
            }

            const base_width = Util.m_to_wgs_84_deg(100 * Math.max(1, .005 * (Util.wgs_84_ddeg_to_m(camera_center.z()) - 1700))); // base width of a detail tile given in meters
            const width_multiplier = Math.cos(camera_center.x() / 180 * Math.PI); // x is latitude
            // grid jump for triangles is done all x meters
            let grid_offset_pos = get_detail_base_pos(Pos(camera_center.x(), camera_center.y()), base_width * 0.125);
            let grid_offset_pos_rel = Pos(grid_offset_pos.lat - camera_center.x(), grid_offset_pos.lon - camera_center.y());
            // drawing the hq center triangles
            gl.uniform1i(program.uniform_locations.tile_width, 100);
            gl.uniform2f(program.uniform_locations.tile_width_m, base_width, width_multiplier);
            gl.uniform2f(program.uniform_locations.grid_offset_pos, grid_offset_pos.lat, grid_offset_pos.lon);
            gl.uniform2f(program.uniform_locations.grid_offset_pos_rel, grid_offset_pos_rel.lat, grid_offset_pos_rel.lon);
            gl.drawArrays(gl.TRIANGLES, 0, 6 * 100 * 100);

            // drawing the surrounding lower quality triangles
            const radius = 7;
            const triangle_resolution = 200;
            gl.uniform1i(program.uniform_locations.tile_width, triangle_resolution);
            let cur_d = base_width;
            let cur_base_pos = Pos(grid_offset_pos.lat - cur_d, grid_offset_pos.lon - cur_d);
            const draw_patch = (cam, cur_base_pos, tile_width_m) => {
                const cur_base_pos_rel = Pos(cur_base_pos.lat - cam.x(), cur_base_pos.lon - cam.y());
                gl.uniform2f(program.uniform_locations.tile_width_m, tile_width_m, width_multiplier);
                gl.uniform2f(program.uniform_locations.grid_offset_pos, cur_base_pos.lat, cur_base_pos.lon);
                gl.uniform2f(program.uniform_locations.grid_offset_pos_rel, cur_base_pos_rel.lat, cur_base_pos_rel.lon);
                gl.drawArrays(gl.TRIANGLES, 0, 6 * triangle_resolution * triangle_resolution);
            };
            for (let i = 0; i < radius; ++i, cur_d *= 3, cur_base_pos.lat -= cur_d, cur_base_pos.lon -= cur_d) { // cur d has to be tripled as the block currently rendered has 3 * the cur_d width
                draw_patch(camera_center, cur_base_pos, cur_d);
                draw_patch(camera_center, Pos(cur_base_pos.lat + cur_d, cur_base_pos.lon), cur_d);
                draw_patch(camera_center, Pos(cur_base_pos.lat + 2 * cur_d, cur_base_pos.lon), cur_d);
                draw_patch(camera_center, Pos(cur_base_pos.lat, cur_base_pos.lon + cur_d), cur_d);
                draw_patch(camera_center, Pos(cur_base_pos.lat + 2 * cur_d, cur_base_pos.lon + cur_d), cur_d);
                draw_patch(camera_center, Pos(cur_base_pos.lat, cur_base_pos.lon + 2 * cur_d), cur_d);
                draw_patch(camera_center, Pos(cur_base_pos.lat + cur_d, cur_base_pos.lon + 2 * cur_d), cur_d);
                draw_patch(camera_center, Pos(cur_base_pos.lat + 2 * cur_d, cur_base_pos.lon + 2 * cur_d), cur_d);
            }
        }
        let start = performance.now();
        // draw tile ids ---------------------------------------
        draw_tiles(gl_context, { width: indices_render_objs.width, height: indices_render_objs.height }, render_pipelines.idx, indices_render_objs.fb);

        // draw normal frame -----------------------------------
        draw_tiles(gl_context, { width: canvas3d.width, height: canvas3d.height }, render_pipelines.terrain, null); // null sets teh default canvas framebuffer as target
        console.log(`drawing took ${performance.now() - start} milli`);
        start = performance.now();

        // get needed tile indices
        gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, indices_render_objs.fb);
        const width = indices_render_objs.width;
        const height = indices_render_objs.height;
        let data = new Uint8Array(width * height * 4);   // reinterpret cast the uint8_t as uint16_t
        // const sync = gl_context.fenceSync(gl_context.SYNC_GPU_COMMANDS_COMPLETE, 0);
        // gl_context.flush();
        // gl_context.clientWaitSync(sync, 0, 100e6);
        // gl_context.deleteSync(sync);
        gl_context.readPixels(0, 0, width, height, gl_context.RGBA, gl_context.UNSIGNED_BYTE, data);
        console.log(`only reading the pixels took ${performance.now() - start} milli`);
        let indices = new Uint32Array(data.buffer);
        let needed_tiles = new Set(indices);
        needed_tiles.delete(0xffffffff);
        console.log(`checking tiles took ${performance.now() - start} milli`);
        let decoded_tiles = Util.int32_to_tile_id(needed_tiles);
        let requested_tiles = decoded_tiles.map(tile => TileRequest().init(tile.x, tile.y, tile.level,
            `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${tile.level}/${tile.x}/${tile.y}.png`
        ));
        virtual_height_map.update_needed_tiles(requested_tiles);
        let s = document.getElementById("layer_select");
        let layer = s.options[s.selectedIndex];
        let requested_streetmap_tiles = decoded_tiles.map(tile => TileRequest().init(tile.x, tile.y, tile.level,
            `https://${layer.getAttribute("base_url")}${tile.level}/${tile.x}/${tile.y}${layer.getAttribute("ending")}`
        ));
        virtual_street_map.update_needed_tiles(requested_streetmap_tiles);
        console.log(decoded_tiles);
    }
    function check_virtual_textures_update() {
        virtual_height_map.upload_loaded_images();
        virtual_street_map.upload_loaded_images();
        if (virtual_height_map.virtual_texture_rebuilt || virtual_street_map.virtual_texture_rebuilt) {
            virtual_height_map.virtual_texture_rebuilt = false;
            virtual_street_map.virtual_texture_rebuilt = false;
            draw_scene();
        }
    }
    // ----------------------------------------------------------------------------------------
    // init section (contains also the shader code)
    // ----------------------------------------------------------------------------------------

    async function init() {
        // webgl init
        gl_context = canvas3d.getContext('webgl2', {antialias: true}) || canvas3d.getContext('experimental-webgl2');
        if (!gl_context) {
            alert('Unable to initialize WebGL. Your browser or machine may not support it');
            return;
        }

        const vs = `#version 300 es
        #define PI 3.1415926535897932384626433832795
        precision highp int;
        precision highp float;
        precision highp sampler2DArray;
        precision highp usampler2D;

        uniform int tile_width;             // tile width in vertex count, always equals the tile height
        uniform vec2 tile_width_m;         // tile width in meters, always equals the tile height
        uniform vec2 grid_offset_pos;
        uniform vec2 grid_offset_pos_rel;   // is the relative offset position which is relative to the viewer position
        uniform mat4 view_proj;
        ${Util.glsl_virtual_texture_uniforms("heightmap")}

        // out variables
        out vec2 loc_pos;
        flat out vec2 pos_off;
        out float height_m;

        ${Util.glsl_wgs_84_m_to_ddeg()}
        ${Util.glsl_wgs_84_to_uv()}
        ${Util.glsl_virtual_texture_load("heightmap")}
        
        void main(void) {
            int quad_idx = gl_VertexID % 6 / 3;
            int triangle_idx = gl_VertexID % 3;
            int pos_off_x = gl_VertexID / 6 % tile_width;
            int pos_off_y = gl_VertexID / 6 / tile_width;
            int x_offset = int(triangle_idx == 1) ^ quad_idx;
            int y_offset = int(triangle_idx == 2) ^ quad_idx;
            float x = float(pos_off_x + x_offset) / float(tile_width) * tile_width_m.x;
            float y = float(pos_off_y + y_offset) / float(tile_width) * tile_width_m.x;
            
            loc_pos = vec2(x, y);
            vec2 world_pos = vec2(x, y);
            world_pos += grid_offset_pos;
            pos_off = grid_offset_pos;

            // get height vertex height
            vec2 uv_glob = wgs_84_to_uv(world_pos);
            vec4 encoded_height = virtual_heightmap_load(uv_glob) * 256.;
            height_m = (encoded_height.r * 256. + encoded_height.g + encoded_height.b / 256.) - 32768.;
            float height = wgs_84_m_to_ddeg(height_m);
            if (encoded_height == vec4(0))
                height = 0.;

            vec4 pos_cam_rel = vec4(x, y, height, 1.);
            pos_cam_rel.xy += grid_offset_pos_rel;
            pos_cam_rel.y *= tile_width_m.y; // accommodate for circumference reduction of earth depending on the latitude

            gl_Position = view_proj * pos_cam_rel;
            // vs_tid = float(gl_VertexID / 3);
            // w_pos = pos_cam_rel.xyz;
        }
        `;
        const fs = `#version 300 es
        #define PI 3.1415926535897932384626433832795
        precision highp int;
        precision highp float;
        precision highp sampler2DArray;
        precision highp usampler2D;

        in vec2 loc_pos;
        flat in vec2 pos_off;
        in float height_m;
        ${Util.glsl_virtual_texture_uniforms("streetmap")}

        ${Util.glsl_wgs_84_m_to_ddeg()}
        ${Util.glsl_wgs_84_to_uv()}
        ${Util.glsl_virtual_texture_load("streetmap")}
        ${Util.glsl_get_tile_index()}

        out vec4 out_col; 
        void main(void) {
            // if (distance(world_pos, vec2(47.80168, 12.89865)) < 1e-3)
            //     out_col = vec4(1., 0., 0., 1.);
            // else
            //     out_col = vec4(sin(vs_tid * .134), sin(vs_tid * .143 + .3), sin(vs_tid * 0.143 + .67), 1.);

            // out_col = vec4((w_pos.z - 400.) / 300.);
            // return;
            // out_col = vec4(world_pos / 1000., 0., 1.);
            // return;

            // vec2 uv_glob;
            // vec3 tile_id = vec3(get_tile_index_uv(uv_glob));
            
            // uint t = texture(virtual_streetmap_index, vec2(gl_FragCoord.xy) / vec2(textureSize(virtual_streetmap_index, 0).xy) * 40.).x;
            // out_col = texture(virtual_heightmap, vec3(uv_glob, float(t - 1u)));
            // return;
            // if (t == 0u)
            //     out_col = vec4(1., 0, 0, 1);
            // else
            //     out_col = vec4(float(t % 10u) * .1);
            // return;

            // ivec2 pixel_pos = ivec2(gl_FragCoord.xy);
            // ivec2 xy = pixel_pos % 256;
            // ivec2 tile = pixel_pos / 256;
            // int lev = tile.x + tile.y * 16;
            // out_col = texelFetch(virtual_streetmap, ivec3(xy, lev), 0);
            // return;

            // uint t = texelFetch(virtual_heightmap_index, pixel_pos, 0).r;
            // if (min(pixel_pos, textureSize(virtual_heightmap_index, 0)) != pixel_pos) {
            //     out_col = vec4(1., 0, 0, 1.);
            //     return;
            // }
            // if (t != 0u)
            //     out_col = vec4(1.);
            // else
            //     out_col = vec4(0.);
            // return;

            vec2 uv_glob = wgs_84_to_uv(loc_pos + pos_off);
            vec4 surface_col = virtual_streetmap_load(uv_glob);
            if (surface_col == vec4(0))
                surface_col = vec4(.85);
            out_col = vec4(surface_col.xyz, 1);
            // out_col = mix(out_col, vec4(1, 0, 0, 1), 1. - clamp(abs(height_m - floor(height_m / 20.) * 20. - 1.), 0., 1.));
            // float mist = pow((gl_FragCoord.z / gl_FragCoord.w), .3);
            // vec3 desat = vec3(dot(out_col.xyz, vec3(0.33)));
            // out_col.xyz = mix(out_col.xyz, vec3(1), mist);
        }
        `;

        const fs_id = `#version 300 es
        #define PI 3.1415926535897932384626433832795
        precision highp int;
        precision highp float;
        precision highp sampler2DArray;
        precision highp usampler2D;

        in vec2 loc_pos;
        flat in vec2 pos_off;

        ${Util.glsl_wgs_84_to_uv()}
        ${Util.glsl_wgs_84_ddeg_to_m()}
        ${Util.glsl_get_tile_index()}

        out vec4 out_col; 
        void main(void) {
            ivec3 tile_id = get_tile_index();
            float div = float((1 << 8) - 1);
            out_col = vec4(float(tile_id.y & 0xff) / div,
                           float(((tile_id.x & 3) << 6) | ((tile_id.y >> 8) & 0x3f)) / div,
                           float((tile_id.x >> 2) & 0xff) / div, 
                           float((tile_id.z << 4) | ((tile_id.x >> 10)) & 0xf) / div);
        }
        `;

        const create_pipeline = (gl_context, vs, fs) => {
            const pipeline = initShaderProgram(gl_context, vs, fs);
            return {
                program: pipeline,
                uniform_locations: {
                    tile_width: gl_context.getUniformLocation(pipeline, 'tile_width'),
                    tile_width_m: gl_context.getUniformLocation(pipeline, 'tile_width_m'),
                    grid_offset_pos: gl_context.getUniformLocation(pipeline, 'grid_offset_pos'),
                    grid_offset_pos_rel: gl_context.getUniformLocation(pipeline, 'grid_offset_pos_rel'),
                    view_proj: gl_context.getUniformLocation(pipeline, 'view_proj'),
                    virtual_heightmap_index: gl_context.getUniformLocation(pipeline, 'virtual_heightmap_index'),
                    virtual_heightmap: gl_context.getUniformLocation(pipeline, 'virtual_heightmap'),
                    virtual_heightmap_infos: gl_context.getUniformBlockIndex(pipeline, "Infos_heightmap"),
                    virtual_streetmap_index: gl_context.getUniformLocation(pipeline, 'virtual_streetmap_index'),
                    virtual_streetmap: gl_context.getUniformLocation(pipeline, 'virtual_streetmap'),
                    virtual_streetmap_infos: gl_context.getUniformBlockIndex(pipeline, "Infos_streetmap"),
                }
            };
        };
        render_pipelines = {
            terrain: create_pipeline(gl_context, vs, fs),
            idx: create_pipeline(gl_context, vs, fs_id),
        };

        // let meta = await fetch(location.origin + "/heightmap/meta");
        // heightmap_meta_data = await meta.json();
        // // adding center info
        // for (let key in heightmap_meta_data) {
        //     let cur = heightmap_meta_data[key];
        //     cur.center_lat = cur.min_lat + 500;
        //     cur.center_lon = cur.min_lon + 500;
        // }

        camera_center = Vec4(47.80177, 12.89798, Util.m_to_wgs_84_deg(1100));
        bayernatlas_data = {
            meta: {
                origin: [3927040, 5923328],
                resolutions: [4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1, 0.5, 0.25],
                tile_size: 256,     // factor that the resolution has to be multiplied by to get the per tile size
                server_urls: ["intergeo31.bayernwolke.de/betty/", "intergeo32.bayernwolke.de/betty/", "intergeo33.bayernwolke.de/betty/", "intergeo34.bayernwolke.de/betty/", "intergeo35.bayernwolke.de/betty/", "intergeo36.bayernwolke.de/betty/", "intergeo37.bayernwolke.de/betty/", "intergeo38.bayernwolke.de/betty/", "intergeo39.bayernwolke.de/betty/", "intergeo40.bayernwolke.de/betty/"],
                map_folder: "atkis/",
                satellite_folder: "satdop40_komplett"
            },
            load_cache: [],         // is being filled with images that should be downloaded
            loaded_images: [],
        }

        // linalg_tests();
        const is_mobile = navigator.userAgentData ? navigator.userAgentData.mobile: false;
        const is_chrome = navigator.userAgent.toLowerCase().indexOf("chrome") > -1;
        const max_depth = is_mobile && is_chrome ? 12: 14;
        const v_width = 1 << max_depth;
        virtual_height_map = VirtualMap().init(v_width, v_width, { min_lat: 0, max_lat: 360, min_lon: -90, max_lon: 90 }, 256, 256, 255, TextureTypes(gl_context).un8rgba, gl_context);
        virtual_street_map = VirtualMap().init(v_width, v_width, { min_lat: 0, max_lat: 360, min_lon: -90, max_lon: 90 }, 256, 256, 255, TextureTypes(gl_context).un8rgba, gl_context);
        // starting the endless loop for updating the image cache
        // setInterval(update_cached_images);
        setInterval(check_virtual_textures_update);
        resizeCanvasToDisplaySize(canvas3d, indices_render_objs, gl_context);
        draw_scene();
    }
    window.onload = init;

    const Pos = (lat, lon) => {
        return {
            lat: lat,
            lon: lon,
            to_string: function () { return '{' + String(this.lat) + ', ' + String(this.lon) + '}'; },
        }
    };

    const get_detail_base_pos = (pos, divider) => {
        // as the tiles are always increasing by 100, and we want a transfer of triangles
        // in 1/10th of the difference, we round the pos to multiple of 100 in each direction
        const offset = divider * 5;
        return Pos(Math.floor(pos.lat / divider) * divider - offset, Math.floor(pos.lon / divider) * divider - offset);
    };

    // constructs the forward vector which also takes pitch into account (if looking down, the front vector should also go down
    const get_forward_dir = (dir, pitch) => { return Vec4(Math.sin(dir) * Math.cos(pitch), Math.cos(dir) * Math.cos(pitch), Math.sin(pitch), 0); };
    // constructs the right vector which is independent of the viewing pitch
    const get_right_dir = (dir) => { return Vec4(Math.cos(-dir), Math.sin(-dir), 0, 0); }; // the - sign is added as the we interpret the direction to go clock-wise

    // ----------------------------------------------------------------------------------------
    // The following two functions are from https://mdn.github.io/webgl-examples/tutorial/sample5/index.html
    // ----------------------------------------------------------------------------------------

    // init shader program.
    function initShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
        // Create the shader program
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        // If creating the shader program failed, alert
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
            return null;
        }
        return shaderProgram;
    }

    //
    // creates a shader of the given type, uploads the source and
    // compiles it.
    //
    function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        // Send the source to the shader object
        gl.shaderSource(shader, source);
        // Compile the shader program
        gl.compileShader(shader);
        // See if it compiled successfully
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function resizeCanvasToDisplaySize(canvas, fb, gl) {
        // Lookup the size the browser is displaying the canvas in CSS pixels.
        const displayWidth = canvas.clientWidth;
        const displayHeight = canvas.clientHeight;
        // Check if the canvas is not the same size.
        const needResize = canvas.width !== displayWidth ||
            canvas.height !== displayHeight;
        if (needResize) {
            // Make the canvas the same size
            canvas.width = displayWidth;
            canvas.height = displayHeight;


            if (fb && gl) {
                fb.width = Math.floor(displayWidth / 4);
                fb.height = Math.floor(displayHeight / 4);

                if (fb.texture)
                    gl.deleteTexture(fb.texture);
                if (fb.fb)
                    gl.deleteFramebuffer(fb.fb);
                fb.texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, fb.texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, fb.width, fb.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                fb.fb = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fb.fb);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fb.texture, 0);
            }
        }
        // create camera projection matrices
        camera_perspective = PerspectiveFov(60, displayWidth / displayHeight, .0001, 100);
        const screen_size_factor = 1;
        camera_orthographic = Orthographic(displayHeight * screen_size_factor, displayWidth * screen_size_factor, .0001, 10000);
        return needResize;
    }
    window.addEventListener("resize", async () => {
        let height = String(document.documentElement.clientHeight - document.getElementById("header").clientHeight) + "px";
        canvas3d.style.height = height;
        resizeCanvasToDisplaySize(canvas3d, indices_render_objs, gl_context);
        await draw_scene();
    });
</script>

</html>