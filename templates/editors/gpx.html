<!DOCTYPE html>

<html>

<head>
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <title>Gpx Editor</title>
    <style>
        html * {
            font-family: Arial, Helvetica, sans-serif;
            font-size: min(2vw, .5cm);
        }

        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0px;
            overflow: hidden;
        }

        body {
            display: table;
        }

        a {
            cursor: pointer;
        }

        button {
            border: none;
            background-color: white;
            cursor: pointer;
        }

        .preview {
            height: 100%;
            width: 100%;
            background-color: black;
        }

        .fill {
            width: 100%;
            height: 100%;
        }

        #header,
        #content {
            display: table-row;
        }

        #header+#content {
            height: 100%;
        }

        #canvas3d {
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="header">
        {{#editor}}
        <center id="title">GPX Editor</center>
        <button id="save" onclick="save();">&#128190;</button>
        <select id="layer_select" onchange="virtual_street_map.drop_least_important_tiles(null, true).drop_least_important_tiles(null, false);">
            <option base_url="tile.openstreetmap.org/" ending=".png" detail_switch_level="19">OSM</option>
            <option base_url="c.tile-cyclosm.openstreetmap.fr/cyclosm/" ending=".png" detail_switch_level="20">CyclOSM</option>
            <option base_url="server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/" swap_xy="true" detail_switch_level="22">Satellit</option>
            <option base_url="intergeo33.bayernwolke.de/betty/atkis/" ending="" detail_switch_level="18">Straßen bayern</option>
            <option base_url="intergeo37.bayernwolke.de/betty/g_atkis3d/" ending="" detail_switch_level="18">Straßen bayern 3d</option>
            <option base_url="intergeo31.bayernwolke.de/betty/g_satdop40_komplett/" ending="" detail_switch_level="18" col_corr_b=".85">Satellit bayern</option>
            <option base_url="intergeo37.bayernwolke.de/betty/c_hist/" ending="" detail_switch_level="14">Historisch bayern</option>
            <option base_url="intergeo36.bayernwolke.de/betty/c_dgm_relief/" ending="" detail_switch_level="14">Gelände relief</option>
        </select>
        <input id="enable_tile_update" type="checkbox" checked onchange="draw_scene();">
        <label for="enable_tile_update">Karten tiles nachladen</label>
        <input id="triangle_resolution" type="number" min="10" max="1000" value="400">
        <label for="triangle_resolution">Geometrieauflösung</label>
        <input id="enable_cam_follow" type="checkbox">
        <label for="enable_cam_follow">Kamera folgen</label>
        {{/editor}}
    </div>
    <div id="content">
        <div id="preview" class="preview">
            <canvas id="canvas3d" class="fill"></canvas>
        </div>
    </div>
</body>
<script type="text/javascript" src="{{&site_url}}/lin_alg.js"></script>
<script type="text/javascript" src="{{&site_url}}/virtual_texture.js"></script>
<script type="text/javascript" src="{{&site_url}}/pro4.js"></script>
<!--<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js"></script>-->
<script>
    // var spector = new SPECTOR.Spector();
    // spector.displayUI();
    // spector.spyCanvases();

    const user_credentials = "{{credentials}}";
    const file_path = "{{&file_path}}";

    let canvas3d = document.getElementById("canvas3d");
    let canvas_tile_ids_2d_ctx = null;
    let canvas_drag_start = null;
    let camera_state = {};  // contains all camera state for rendering
    let gl_context = null;
    let indices_render_objs = {}; // object containing render objects needed for index rendering
    let render_pipelines = null;
    let camera_center = null;
    let camera_updated = false;
    const cam_rot_speed = .002;
    const cam_dir_speed = Util.m_to_wgs_84_uv(1); // go forward 1 meter
    const up_dir = Vec4(0, 0, 1, 0);
    let camera_dir = 0;     // given in radians, 0 means dead north
    let camera_pitch = 0;   // given in radians, 0 means straight ahead, pi straight up -pi straight down
    let camera_perspective = null;
    let camera_orthographic = null;
    let camera_interpolation = 0; // interpolation value between orthographic and projection mapping (0 means full projection, 1 means full orthographic)
    let heightmap_meta_data = null;
    /** @type {VirtualHeightMap} */
    let virtual_height_map = null;
    let virtual_street_map = null;
    let cur_gps_pos = null;
    const dist = (x1, y1, x2, y2) => {let x = x2 - x1, y = y2 - y1; return Math.sqrt(x * x + y * y);}
    canvas3d.addEventListener("mousedown", (e) => { canvas_drag_start = { x: e.screenX, y: e.screenY, type: e.button == 0 ? "move" : e.button == 1 || e.button == 2 ? "rotate": "unknown"}; });
    canvas3d.addEventListener("touchstart", (e) => {
                              let x = e.touches.length == 1 ? e.touches[0].screenX: .5 * e.touches[0].screenX + .5 * e.touches[1].screenX;
                              let y = e.touches.length == 1 ? e.touches[0].screenY: .5 * e.touches[0].screenY + .5 * e.touches[1].screenY;
                              canvas_drag_start = { x: x, y: y, 
                              dist: e.touches.length == 2? dist(e.touches[0].screenX, e.touches[0].screenY, e.touches[1].screenX, e.touches[1].screenY): 0, 
                              type: e.touches.length == 1 ? "move": "rotate"}; });
    const move_camera = (cur_move) => {
        if (canvas_drag_start) {
            let xDel = canvas_drag_start.x - cur_move.x;
            let yDel = canvas_drag_start.y - cur_move.y;
            let height_multiplier = Math.max(1, .001 * (Util.wgs_84_uv_to_m(camera_center.z()) - 1100));
            let speed = cam_dir_speed * height_multiplier;
            switch(canvas_drag_start.type) {
            case "move":
                camera_center.add(get_front_dir(camera_dir, camera_pitch).mul(speed * yDel));
                camera_center.add(get_right_dir(camera_dir).mul(speed * xDel));
                break;
            case "rotate":
                if (cur_move.dist) {
                    let zoomDel = canvas_drag_start.dist - cur_move.dist;
                    if (Math.abs(zoomDel) > Math.abs(xDel) && Math.abs(zoomDel) > Math.abs(yDel)) {
                        camera_center.add(get_forward_dir(camera_dir, camera_pitch).mul(speed * zoomDel * 2));
                        xDel = 0;
                        yDel = 0;
                    }
                }
                camera_dir -= xDel * cam_rot_speed * 2;
                if (camera_dir > 2 * Math.PI) camera_dir -= 2 * Math.PI;
                if (camera_dir < 0) camera_dir += 2 * Math.PI;
                camera_pitch += yDel * cam_rot_speed * 2;
                if (camera_pitch > Math.PI / 2) camera_pitch = Math.PI / 2;
                if (camera_pitch < -Math.PI / 2) camera_pitch = -Math.PI / 2;
                break;
            default: console.error("Unknown move type " + canvas_drag_start.type);
            }
            canvas_drag_start = cur_move;
            camera_updated = true;
        }
    };
    canvas3d.addEventListener("mousemove", (e) => {
        if (!canvas_drag_start)
            return;
        let cur_move = {x: e.screenX, y: e.screenY, type: canvas_drag_start.type || "unknown"};
        move_camera(cur_move);
        e.preventDefault();
    });
    canvas3d.addEventListener("touchmove", (e) => {
        if (!canvas_drag_start)
            return;
        let x = e.touches.length == 1 ? e.touches[0].screenX: .5 * e.touches[0].screenX + .5 * e.touches[1].screenX;
        let y = e.touches.length == 1 ? e.touches[0].screenY: .5 * e.touches[0].screenY + .5 * e.touches[1].screenY;
        let cur_move = {x: x, y: y,
            dist: e.touches.length == 2? dist(e.touches[0].screenX, e.touches[0].screenY, e.touches[1].screenX, e.touches[1].screenY): 0, 
            type: canvas_drag_start.type || "unknown"};
        move_camera(cur_move);
        e.preventDefault();
    });
    canvas3d.addEventListener("mouseup", (e) => { canvas_drag_start = null; });
    canvas3d.addEventListener("mouseleave", (e) => { canvas_drag_start = null; });
    canvas3d.addEventListener("touchend", (e) => { canvas_drag_start = null; });
    canvas3d.addEventListener("touchcancel", (e) => { canvas_drag_start = null; });
    canvas3d.addEventListener("wheel", (e) => {
        let height_multiplier = Math.max(1, .01 * (Util.wgs_84_uv_to_m(camera_center.z()) - 1100));
        camera_center.add(get_forward_dir(camera_dir, camera_pitch).mul(.1 * cam_dir_speed * height_multiplier * e.deltaY));
        draw_scene();
    });
    let pressed_keys = {};
    window.addEventListener("keydown", async (e) => {
        if (document.querySelector(".preview:hover") == null)
            return;

        let height_multiplier = Math.max(1, .001 * (Util.wgs_84_uv_to_m(camera_center.z()) - 1100));
        let speed = cam_dir_speed * height_multiplier;
        let key = e.key;
        if (key === key.toUpperCase()) {
            key = key.toLowerCase();
            speed *= 100;
        }
        if (key === "w")
            camera_center.add(get_forward_dir(camera_dir, camera_pitch).mul(-speed));
        if (key === "a")
            camera_center.add(get_right_dir(camera_dir).mul(-speed));
        if (key === "s")
            camera_center.add(get_forward_dir(camera_dir, camera_pitch).mul(speed));
        if (key === "d")
            camera_center.add(get_right_dir(camera_dir).mul(speed));
        if (key === "q")
            camera_center.add(up_dir.multiply(-speed));
        if (key === "e")
            camera_center.add(up_dir.multiply(speed));
        e.preventDefault();
        camera_updated = true;
    });

    function filter_object(obj, callback) {
        return Object.fromEntries(Object.entries(obj).filter(([key, val]) => callback(key, val)));
    };
    
    function get_selected_layer() {
        let s = document.getElementById("layer_select");
        return s.options[s.selectedIndex];
    };

    // draws the scene with all loaded data
    let data = null;
    let in_flight = false;
    async function draw_scene() {
        if (!gl_context)
            return;

        // creating the view matrix -------------------------------------------
        const base_width = Util.m_to_wgs_84_uv(100 * Math.max(1, .0005 * (Util.wgs_84_uv_to_m(camera_center.z()) - 1700))); // base width of a detail tile given in meters
        // grid jump for triangles is done all x meters
        let grid_offset_pos = get_detail_base_pos(Pos(camera_center.x(), camera_center.y()), base_width * 0.125);
        let at = get_forward_dir(camera_dir, camera_pitch).to_absolute_vec();
        at.entries[0] += camera_center.x() - grid_offset_pos.lat;
        at.entries[1] += camera_center.y() - grid_offset_pos.lon;
        at.entries[2] += camera_center.z();
        const view = LookAt(Vec4(camera_center.x() - grid_offset_pos.lat, camera_center.y() - grid_offset_pos.lon, camera_center.z(), 1), // camera_center is always in the center, the tiles a re moved relative to the camera center
            at,
            up_dir);
        let view_projection = camera_perspective.morph(camera_orthographic, camera_interpolation);
        view_projection.mul(view);  // inplace multiplication which corresponds to Proj * View which means the view matrix is applied before the projection

        // drawing the tiles --------------------------------------------------
        const overlap_width = (1 << 22) / virtual_height_map.v_tex_width;
        const half_overlap = overlap_width >> 1;
        let detail_corner = {x: Math.floor(camera_center.x() * virtual_height_map.v_tex_coarse_width - half_overlap) / virtual_height_map.v_tex_coarse_width, 
                             y: Math.floor(camera_center.y() * virtual_height_map.v_tex_coarse_height - half_overlap) / virtual_height_map.v_tex_coarse_height};
        const draw_tiles = (gl, fb_size, program, framebuffer) => {
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.viewport(0, 0, fb_size.width, fb_size.height);
            gl.clearColor(1., 1., 1., 1.0);
            gl.clearDepth(1.0);

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.enable(gl.DEPTH_TEST);

            gl.useProgram(program.program);
            gl.uniformMatrix4fv(program.uniform_locations.view_proj, false, view_projection.entries);
            gl.uniform2f(program.uniform_locations.detail_corner, detail_corner.x, detail_corner.y);
            if (program.uniform_locations.color_correction) { 
                let selected_layer = get_selected_layer();
                let b = 1.;
                let attr = selected_layer.getAttribute("col_corr_b");
                if (attr)
                    b = parseFloat(attr);
                gl.uniform4f(program.uniform_locations.color_correction, 1, 1, b, 1);
            }
            
            // binding the virtual textures
            virtual_height_map.bind_to_shader(gl.TEXTURE0, gl.TEXTURE1, gl.TEXTURE2, program.uniform_locations.virtual_heightmap_infos);
            gl.uniform1i(program.uniform_locations.virtual_heightmap_index, 0);
            gl.uniform1i(program.uniform_locations.virtual_heightmap_index_detail, 1);
            gl.uniform1i(program.uniform_locations.virtual_heightmap, 2);
            gl.uniformBlockBinding(program.program, program.uniform_locations.virtual_heightmap_infos, program.uniform_locations.virtual_heightmap_infos);
            if (program.uniform_locations.virtual_streetmap_infos < 10) {
                virtual_street_map.bind_to_shader(gl.TEXTURE3, gl.TEXTURE4, gl.TEXTURE5, program.uniform_locations.virtual_streetmap_infos);
                gl.uniform1i(program.uniform_locations.virtual_streetmap_index, 3);
                gl.uniform1i(program.uniform_locations.virtual_streetmap_index_detail, 4);
                gl.uniform1i(program.uniform_locations.virtual_streetmap, 5);
                gl.uniformBlockBinding(program.program, program.uniform_locations.virtual_streetmap_infos, program.uniform_locations.virtual_streetmap_infos);
            }
            // drawing the hq center triangles
            const triangle_resolution = + document.getElementById("triangle_resolution").value;
            gl.uniform1i(program.uniform_locations.tile_width, 100);
            gl.uniform1i(program.uniform_locations.geo_res, triangle_resolution);
            if (cur_gps_pos)
                gl.uniform2f(program.uniform_locations.cur_gps_pos_loc, cur_gps_pos.lat - grid_offset_pos.lat, cur_gps_pos.lon - grid_offset_pos.lon);
            else
                gl.uniform2f(program.uniform_locations.cur_gps_pos_loc, -1e10, -1e10);
            gl.uniform2f(program.uniform_locations.tile_width_uv, base_width, 1.);
            gl.uniform2f(program.uniform_locations.grid_offset_pos, grid_offset_pos.lat, grid_offset_pos.lon);
            gl.uniform2f(program.uniform_locations.grid_offset_pos_rel, 0, 0);
            gl.uniform2f(program.uniform_locations.cam_off, camera_center.x() - grid_offset_pos.lat, camera_center.y() - grid_offset_pos.lon);
            gl.drawArrays(gl.TRIANGLES, 0, 6 * 100 * 100);

            // drawing the surrounding lower quality triangles
            const radius = 7;
            let cur_d = base_width;
            const center_triangles_per_width = 100 / base_width;
            let cur_base_pos = Pos(grid_offset_pos.lat - cur_d, grid_offset_pos.lon - cur_d);
            const inside_view = (base_pos, width) => {
                const x = base_pos.lat;
                const y = base_pos.lon;
                const z = Util.m_to_wgs_84_uv(5000 * 1.4);
                let p1 = view_projection.multiply(Vec4(x, y));
                let p2 = view_projection.multiply(Vec4(x + width, y));
                let p3 = view_projection.multiply(Vec4(x, y + width));
                let p4 = view_projection.multiply(Vec4(x + width, y + width));
                let p1u = view_projection.multiply(Vec4(x, y, z));
                let p2u = view_projection.multiply(Vec4(x + width, y, z));
                let p3u = view_projection.multiply(Vec4(x, y + width, z));
                let p4u = view_projection.multiply(Vec4(x + width, y + width), z);
                p1.mul(1 / p1.w());
                p2.mul(1 / p2.w());
                p3.mul(1 / p3.w());
                p4.mul(1 / p4.w());
                p1u.mul(1 / p1u.w());
                p2u.mul(1 / p2u.w());
                p3u.mul(1 / p3u.w());
                p4u.mul(1 / p4u.w());
                if (p1.z() < 0 && p2.z() < 0 && p3.z() < 0 && p4.z() < 0) return false;
                if (p1.z() > 1 && p2.z() > 1 && p3.z() > 1 && p4.z() > 1) return false;

                if (p1.x() < -1 && p2.x() < -1 && p3.x() < -1 && p4.x() < -1) return false;
                if (p1.x() > 1 && p2.x() > 1 && p3.x() > 1 && p4.x() > 1) return false;

                // if (p1.y() < -1 && p2.y() < -1 && p3.y() < -1 && p4.y() < -1) return false;
                // if (p1u.y() > 1 && p2u.y() > 1 && p3u.y() > 1 && p4u.y() > 1) return false;
                return true;
            };
            let i = inside_view({lat: 0, lon: 0}, base_width);
            let draw_count = 0;
            const draw_patch = (cam, cur_base_pos, tile_width_uv) => {
                const cur_base_pos_rel = Pos(cur_base_pos.lat - grid_offset_pos.lat, cur_base_pos.lon - grid_offset_pos.lon);
                if (!inside_view(cur_base_pos_rel, tile_width_uv))
                    return;
                ++draw_count;
                const cur_triangles = Math.round(Math.min(center_triangles_per_width, triangle_resolution / tile_width_uv) * tile_width_uv);
                gl.uniform1i(program.uniform_locations.tile_width, cur_triangles);
                gl.uniform2f(program.uniform_locations.tile_width_uv, tile_width_uv, 1.);
                gl.uniform2f(program.uniform_locations.grid_offset_pos_rel, cur_base_pos_rel.lat, cur_base_pos_rel.lon);
                gl.drawArrays(gl.TRIANGLES, 0, 6 * cur_triangles * cur_triangles);
            };
            for (let i = 0; i < radius; ++i, cur_d *= 3, cur_base_pos.lat -= cur_d, cur_base_pos.lon -= cur_d) { // cur d has to be tripled as the block currently rendered has 3 * the cur_d width
                gl.uniform2i(program.uniform_locations.tile_p, -1, -1);
                draw_patch(camera_center, cur_base_pos, cur_d);
                gl.uniform2i(program.uniform_locations.tile_p, 0, -1);
                draw_patch(camera_center, Pos(cur_base_pos.lat + cur_d, cur_base_pos.lon), cur_d);
                gl.uniform2i(program.uniform_locations.tile_p, 1, -1);
                draw_patch(camera_center, Pos(cur_base_pos.lat + 2 * cur_d, cur_base_pos.lon), cur_d);
                gl.uniform2i(program.uniform_locations.tile_p, -1, 0);
                draw_patch(camera_center, Pos(cur_base_pos.lat, cur_base_pos.lon + cur_d), cur_d);
                gl.uniform2i(program.uniform_locations.tile_p, 1, 0);
                draw_patch(camera_center, Pos(cur_base_pos.lat + 2 * cur_d, cur_base_pos.lon + cur_d), cur_d);
                gl.uniform2i(program.uniform_locations.tile_p, -1, 1);
                draw_patch(camera_center, Pos(cur_base_pos.lat, cur_base_pos.lon + 2 * cur_d), cur_d);
                gl.uniform2i(program.uniform_locations.tile_p, 0, 1);
                draw_patch(camera_center, Pos(cur_base_pos.lat + cur_d, cur_base_pos.lon + 2 * cur_d), cur_d);
                gl.uniform2i(program.uniform_locations.tile_p, 0, 1);
                draw_patch(camera_center, Pos(cur_base_pos.lat + 2 * cur_d, cur_base_pos.lon + 2 * cur_d), cur_d);
            }
            console.log("Drew " + draw_count + "tiles");
        }
        const update_tiles = document.getElementById("enable_tile_update").checked;
        let start = performance.now();
        // draw tile ids ---------------------------------------
        if (update_tiles)
            draw_tiles(gl_context, { width: indices_render_objs.width, height: indices_render_objs.height }, render_pipelines.idx, indices_render_objs.fb);

        // draw normal frame -----------------------------------
        draw_tiles(gl_context, { width: canvas3d.width, height: canvas3d.height }, render_pipelines.terrain, null); // null sets teh default canvas framebuffer as target
        console.log(`drawing took ${performance.now() - start} milli`);
        start = performance.now();

        // get needed tile indices
        if (in_flight || !update_tiles)
            return;
        in_flight = true;
        gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, indices_render_objs.fb);
        const width = indices_render_objs.width;
        const height = indices_render_objs.height;
        if (!data || data.byteLength < width * height * 4) {
            console.debug("Recreating data buffer");
            data = new Uint8Array(width * height * 4);
        }
        // gl_context.flush();
        // gl_context.clientWaitSync(sync, 0, 100e6);
        // gl_context.deleteSync(sync);
        // gl_context.readPixels(0, 0, width, height, gl_context.RGBA, gl_context.UNSIGNED_BYTE, data);
        await readPixelsAsync(gl_context, width, height, data);
        console.log(`only reading the pixels took ${performance.now() - start} milli`);
        start = performance.now();
        let indices = new Uint32Array(data.buffer);
        let needed_tiles = new Set(indices);
        needed_tiles.delete(0xffffffff);
        console.log(`checking tiles took ${performance.now() - start} milli`);
        let decoded_tiles = Util.int32_to_tile_id(needed_tiles);
        decoded_tiles = decoded_tiles.map(e  => {; return {
            level: e.level,
            x: (e.level >= 11 ? e.x + detail_corner.x * (1 << e.level) : e.x),
            y: (e.level >= 11 ? e.y + detail_corner.y * (1 << e.level) : e.y)
        }}
        );
        Util.add_missing_parent_tiles(decoded_tiles);
        // max level for height is tile 15 
        const tile_on_minifuzi = (tile) => {return heightmap_meta_data && heightmap_meta_data.tiles_set && heightmap_meta_data.tiles_set.has(`${tile.level}/${tile.x}/${tile.y}`);}
        let requested_tiles = decoded_tiles.filter(tile => tile_on_minifuzi(tile) || tile.level <= 15).map(tile => TileRequest().init(tile.x, tile.y, tile.level,
            !tile_on_minifuzi(tile) ? `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${tile.level}/${tile.x}/${tile.y}.png`:
                                   `${location.origin}/heightmap/${tile.level}/${tile.x}/${tile.y}`
        ));
        virtual_height_map.update_needed_tiles(requested_tiles, {x: camera_center.x(), y: camera_center.y()});
        let layer = get_selected_layer();
        let requested_streetmap_tiles = decoded_tiles.map(tile => TileRequest().init(tile.x, tile.y, tile.level,
            !layer.getAttribute("swap_xy") ? `https://${layer.getAttribute("base_url")}${tile.level}/${tile.x}/${tile.y}${layer.getAttribute("ending")}`
                                           : `https://${layer.getAttribute("base_url")}${tile.level}/${tile.y}/${tile.x}${layer.getAttribute("ending")}`
        )).filter(e => e.level <= layer.getAttribute("detail_switch_level"));
        virtual_street_map.update_needed_tiles(requested_streetmap_tiles, {x: camera_center.x(), y: camera_center.y()});
        console.log(decoded_tiles);
        in_flight = false;
    }
    function check_virtual_textures_update() {
        let start = performance.now();
        virtual_height_map.upload_loaded_images();
        virtual_street_map.upload_loaded_images();
        if (document.getElementById("enable_cam_follow").checked) {
            const interp_factor = .05;
            let pre_x = camera_center.x();
            let pre_y = camera_center.y();
            // let f = get_forward_dir(camera_dir, camera_pitch);
            // f.mul
            camera_center.entries[0] = interp_factor * cur_gps_pos.lat + (1 - interp_factor) * camera_center.x();
            camera_center.entries[1] = interp_factor * cur_gps_pos.lon + (1 - interp_factor) * camera_center.y();
            camera_updated |= pre_x != camera_center.x() || pre_y != camera_center.y(); 
        }
        if (virtual_height_map.virtual_texture_rebuilt || virtual_street_map.virtual_texture_rebuilt || camera_updated) {
            virtual_height_map.virtual_texture_rebuilt = false;
            virtual_street_map.virtual_texture_rebuilt = false;
            camera_updated = false;
            console.log(`updating virtual textures took ${performance.now() - start} milli`);
            draw_scene();
        }
    }
    function updateGpsPosition(p) {
        let [lat, lon] = Util.wgs_84_to_uv(p.coords.latitude, p.coords.longitude);
        cur_gps_pos = {lat: lat, lon: lon};
        console.log("Update cur_gps_pos:");
        console.log(p);
        console.log(cur_gps_pos);
    }
    // ----------------------------------------------------------------------------------------
    // init section (contains also the shader code)
    // ----------------------------------------------------------------------------------------

    async function init() {
        // webgl init
        gl_context = canvas3d.getContext('webgl2', {antialias: true}) || canvas3d.getContext('experimental-webgl2');
        if (!gl_context) {
            alert('Unable to initialize WebGL. Your browser or machine may not support it');
            return;
        }

        const vs = `#version 300 es
        #define PI 3.1415926535897932384626433832795
        precision highp int;
        precision highp float;
        precision highp sampler2DArray;
        precision highp usampler2D;

        uniform int tile_width;             // tile width in vertex count, always equals the tile height
        uniform int geo_res;
        uniform vec2 tile_width_uv;         // tile width in uvs
        uniform vec2 grid_offset_pos;
        uniform vec2 grid_offset_pos_rel;   // is the relative offset position which is relative to the viewer position
        uniform vec2 cam_off;               // cam off needed to convert the loc_pos to loc_pos_cam (camera at the center)
        uniform mat4 view_proj;
        ${Util.glsl_virtual_texture_uniforms("heightmap")}

        // out variables
        out vec2 loc_pos;
        out float height_m;
        out float n_dot_l;

        ${Util.glsl_calc_level()}
        ${Util.glsl_virtual_heightmap_load()}
        ${Util.glsl_wgs_84_m_to_uv()}
        
        void main(void) {
            int quad_idx = gl_VertexID % 6 / 3;
            int triangle_idx = gl_VertexID % 3;
            int pos_off_x = gl_VertexID / 6 % tile_width;
            int pos_off_y = gl_VertexID / 6 / tile_width;
            int x_offset = int(triangle_idx == 1) ^ quad_idx;
            int y_offset = int(triangle_idx == 2) ^ quad_idx;
            float x = float(pos_off_x + x_offset) / float(tile_width - 1) * tile_width_uv.x;
            float y = float(pos_off_y + y_offset) / float(tile_width - 1) * tile_width_uv.x;
            
            loc_pos = vec2(x, y) + grid_offset_pos_rel;

            // get height vertex height
            float du = length(loc_pos - cam_off) * .05 * (100. / float(geo_res));
            du *= du;
            vec4 d_info = virtual_heightmap_load(grid_offset_pos, loc_pos, get_level(du)); // int(get_level(pow(du, 3.))));
            height_m = d_info.x;
            n_dot_l = (dot(vec3(0, .7, .7), d_info.yzw) * .5 + .5) + .05;
            float height = wgs_84_m_to_uv(height_m);

            vec4 pos_cam_rel = vec4(loc_pos, height * 1.4, 1.); // * sqrt(2) due to 1 / cos(45deg)

            gl_Position = view_proj * pos_cam_rel;
        }
        `;
        const fs = `#version 300 es
        #define PI 3.1415926535897932384626433832795
        precision highp int;
        precision highp float;
        precision highp sampler2DArray;
        precision highp usampler2D;

        in vec2 loc_pos;
        in float height_m;
        in float n_dot_l;
        uniform vec2 grid_offset_pos;
        uniform vec2 detail_corner;
        uniform vec4 color_correction;
        uniform vec2 cur_gps_pos_loc; // gps position in local pos
        ${Util.glsl_virtual_texture_uniforms("streetmap")}
        ${Util.glsl_virtual_texture_uniforms("heightmap")}

        ${Util.glsl_wgs_84_to_uv()}
        ${Util.glsl_virtual_texture_load("streetmap")}
        ${Util.glsl_virtual_heightmap_load()}
        ${Util.glsl_calc_level()}
        ${Util.glsl_get_tile_index()}

        out vec4 out_col; 
        void main(void) {
            if (clamp(loc_pos, vec2(-.5), vec2(.5)) != loc_pos)
                discard;

            // if (distance(world_pos, vec2(47.80168, 12.89865)) < 1e-3)
            //     out_col = vec4(1., 0., 0., 1.);
            // else
            //     out_col = vec4(sin(vs_tid * .134), sin(vs_tid * .143 + .3), sin(vs_tid * 0.143 + .67), 1.);

            // out_col = vec4((w_pos.z - 400.) / 300.);
            // return;
            // out_col = vec4(world_pos / 1000., 0., 1.);
            // return;

            // vec2 uv_glob;
            // vec3 tile_id = vec3(get_tile_index_uv(uv_glob));
            
            // uint t = texture(virtual_streetmap_index, vec2(gl_FragCoord.xy) / vec2(textureSize(virtual_streetmap_index, 0).xy) * 40.).x;
            // out_col = texture(virtual_heightmap, vec3(uv_glob, float(t - 1u)));
            // return;
            // if (t == 0u)
            //     out_col = vec4(1., 0, 0, 1);
            // else
            //     out_col = vec4(float(t % 10u) * .1);
            // return;

            // ivec2 pixel_pos = ivec2(gl_FragCoord.xy);
            // ivec2 xy = pixel_pos % 256;
            // ivec2 tile = pixel_pos / 256;
            // int lev = tile.x + tile.y * 16;
            // out_col = texelFetch(virtual_streetmap, ivec3(xy, lev), 0);
            // return;

            // uint t = texelFetch(virtual_heightmap_index, pixel_pos, 0).r;
            // if (min(pixel_pos, textureSize(virtual_heightmap_index, 0)) != pixel_pos) {
            //     out_col = vec4(1., 0, 0, 1.);
            //     return;
            // }
            // if (t != 0u)
            //     out_col = vec4(1.);
            // else
            //     out_col = vec4(0.);
            // return;

            // vec2 uv_glob = wgs_84_to_uv(loc_pos + pos_off);
            if (distance(loc_pos, cur_gps_pos_loc) / gl_FragCoord.z * gl_FragCoord.w * 1e-6 < 1. / 4e7) {
                out_col = vec4(1, 0, 0, 1);
                return;
            }
            vec4 surface_col = virtual_streetmap_load(grid_offset_pos, loc_pos) * color_correction;
            if (surface_col == vec4(0))
                surface_col = vec4(.85);
            vec4 d_info = virtual_heightmap_load(grid_offset_pos, loc_pos, 18.);
            float nl = (dot(vec3(0, .7, .7), d_info.yzw) * .5 + .5) + .05;
            out_col = vec4(surface_col.xyz, 1) * nl;
            // out_col = mix(out_col, vec4(1, .5, 0, 1), pow(1. - clamp(abs(height_m - floor(height_m / 10.) * 10. - 1.), 0., 1.), 16.));
            // float mist = min(pow((gl_FragCoord.z / gl_FragCoord.w), .4) * 10., 1.);
            // vec3 desat = vec3(dot(out_col.xyz, vec3(0.33))) * 1.5;
            // out_col.xyz = mix(out_col.xyz, vec3(1), mist);
        }
        `;

        const fs_id = `#version 300 es
        #define PI 3.1415926535897932384626433832795
        precision highp int;
        precision highp float;
        precision highp sampler2DArray;
        precision highp usampler2D;

        in vec2 loc_pos;

        uniform vec2 grid_offset_pos;
        uniform vec2 detail_corner;

        ${Util.glsl_calc_level()}
        ${Util.glsl_get_tile_index("heightmap")}

        out vec4 out_col; 
        void main(void) {
            if (clamp(loc_pos, vec2(-.5), vec2(.5)) != loc_pos)
                discard;
            ivec3 tile_id = get_tile_index();
            float div = float((1 << 8) - 1);
            out_col = vec4(float(tile_id.y & 0xff) / div,
                           float(((tile_id.x & 0xf) << 4) | ((tile_id.y >> 8) & 0xf)) / div,
                           float((tile_id.x >> 4) & 0xff) / div, 
                           float(tile_id.z) / div);
        }
        `;

        const create_pipeline = (gl_context, vs, fs) => {
            const pipeline = initShaderProgram(gl_context, vs, fs);
            return {
                program: pipeline,
                uniform_locations: {
                    tile_width: gl_context.getUniformLocation(pipeline, 'tile_width'),
                    geo_res: gl_context.getUniformLocation(pipeline, 'geo_res'),
                    tile_width_uv: gl_context.getUniformLocation(pipeline, 'tile_width_uv'),
                    grid_offset_pos: gl_context.getUniformLocation(pipeline, 'grid_offset_pos'),
                    grid_offset_pos_rel: gl_context.getUniformLocation(pipeline, 'grid_offset_pos_rel'),
                    cam_off: gl_context.getUniformLocation(pipeline, 'cam_off'),
                    view_proj: gl_context.getUniformLocation(pipeline, 'view_proj'),
                    detail_corner: gl_context.getUniformLocation(pipeline, 'detail_corner'),
                    color_correction: gl_context.getUniformLocation(pipeline, "color_correction"),
                    cur_gps_pos_loc: gl_context.getUniformLocation(pipeline, 'cur_gps_pos_loc'),
                    virtual_heightmap_index: gl_context.getUniformLocation(pipeline, 'virtual_heightmap_index'),
                    virtual_heightmap_index_detail: gl_context.getUniformLocation(pipeline, 'virtual_heightmap_index_detail'),
                    virtual_heightmap: gl_context.getUniformLocation(pipeline, 'virtual_heightmap'),
                    virtual_heightmap_infos: gl_context.getUniformBlockIndex(pipeline, "Infos_heightmap"),
                    virtual_streetmap_index: gl_context.getUniformLocation(pipeline, 'virtual_streetmap_index'),
                    virtual_streetmap_index_detail: gl_context.getUniformLocation(pipeline, 'virtual_streetmap_index_detail'),
                    virtual_streetmap: gl_context.getUniformLocation(pipeline, 'virtual_streetmap'),
                    virtual_streetmap_infos: gl_context.getUniformBlockIndex(pipeline, "Infos_streetmap"),
                }
            };
        };
        render_pipelines = {
            terrain: create_pipeline(gl_context, vs, fs),
            idx: create_pipeline(gl_context, vs, fs_id),
        };

        let c = Util.wgs_84_to_uv(47.80177, 12.89798);
        camera_center = Vec4(c[0], c[1], Util.m_to_wgs_84_uv(700 * 1.4));

        // linalg_tests();
        const is_mobile = 'ontouchstart' in document.documentElement;
        if (is_mobile)
            document.getElementById("triangle_resolution").value = 100;
        const max_depth = 18;
        const v_width = 1 << max_depth;
        virtual_height_map = VirtualMap().init(v_width, v_width, {x: c[0], y: c[1]}, 256, 256, 255, TextureTypes(gl_context).un8rgba, gl_context);
        const w_street = 1 << 19;
        virtual_street_map = VirtualMap().init(w_street, w_street, {x: c[0], y: c[1]}, 256, 256, 255, TextureTypes(gl_context).un8rgba, gl_context);
        // starting the endless loop for updating the image cache
        // setInterval(update_cached_images);
        setInterval(check_virtual_textures_update, 16);
        resizeCanvasToDisplaySize(canvas3d, indices_render_objs, gl_context);
        
        try {
            heightmap_meta_data = await (await fetch(location.origin + "/heightmap/meta")).json();
            // adding a set for all the available tiles
            heightmap_meta_data.tiles_set = new Set(heightmap_meta_data.tiles);
        } catch(e) {}
        // draw_scene();
        // console.log = () => {};
        // console.info = () => {};
        
        if (navigator.geolocation)
            navigator.geolocation.watchPosition(updateGpsPosition, ()=>{}, {enableHighAccuracy: true});
    }
    window.onload = init;

    const Pos = (lat, lon) => {
        return {
            lat: lat,
            lon: lon,
            to_string: function () { return '{' + String(this.lat) + ', ' + String(this.lon) + '}'; },
        }
    };

    const f64_to_f32 = (f) => {
        return new Float32Array([f])[0];
    }

    const get_detail_base_pos = (pos, divider) => {
        // as the tiles are always increasing by 100, and we want a transfer of triangles
        // in 1/10th of the difference, we round the pos to multiple of 100 in each direction
        const offset = divider * 5;
        return Pos(f64_to_f32(Math.floor(pos.lat / divider) * divider - offset), f64_to_f32(Math.floor(pos.lon / divider) * divider - offset));
    };

    // constructs the forward vector which also takes pitch into account (if looking down, the front vector should also go down
    const get_forward_dir = (dir, pitch) => { return Vec4(Math.sin(dir) * Math.cos(pitch), Math.cos(dir) * Math.cos(pitch), Math.sin(pitch), 0); };
    // constructs the front vector which is always paralell to the ground (no z direction)
    const get_front_dir = (dir, pitch) => { return Vec4(Math.sin(dir), Math.cos(dir), 0, 0); };
    // constructs the right vector which is independent of the viewing pitch
    const get_right_dir = (dir) => { return Vec4(Math.cos(-dir), Math.sin(-dir), 0, 0); }; // the - sign is added as the we interpret the direction to go clock-wise

    // ----------------------------------------------------------------------------------------
    // The following two functions are from https://mdn.github.io/webgl-examples/tutorial/sample5/index.html
    // ----------------------------------------------------------------------------------------

    // init shader program.
    function initShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
        // Create the shader program
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        // If creating the shader program failed, alert
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
            return null;
        }
        return shaderProgram;
    }

    //
    // creates a shader of the given type, uploads the source and
    // compiles it.
    //
    function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        // Send the source to the shader object
        gl.shaderSource(shader, source);
        // Compile the shader program
        gl.compileShader(shader);
        // See if it compiled successfully
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function resizeCanvasToDisplaySize(canvas, fb, gl) {
        // Lookup the size the browser is displaying the canvas in CSS pixels.
        const displayWidth = canvas.clientWidth;
        const displayHeight = canvas.clientHeight;
        // Check if the canvas is not the same size.
        const needResize = canvas.width !== displayWidth ||
            canvas.height !== displayHeight;
        if (needResize) {
            // Make the canvas the same size
            canvas.width = displayWidth;
            canvas.height = displayHeight;


            if (fb && gl) {
                fb.width = Math.floor(displayWidth / 4);
                fb.height = Math.floor(displayHeight / 4);

                if (fb.texture)
                    gl.deleteTexture(fb.texture);
                if (fb.fb)
                    gl.deleteFramebuffer(fb.fb);
                fb.texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, fb.texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, fb.width, fb.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                fb.fb = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fb.fb);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fb.texture, 0);
            }
        }
        // create camera projection matrices
        camera_perspective = PerspectiveFov(60, displayWidth / displayHeight, 5e-8, .1);
        const screen_size_factor = 1;
        camera_orthographic = Orthographic(displayHeight * screen_size_factor, displayWidth * screen_size_factor, .0001, 10000);
        return needResize;
    }
    window.addEventListener("resize", async () => {
        let height = String(document.documentElement.clientHeight - document.getElementById("header").clientHeight) + "px";
        canvas3d.style.height = height;
        resizeCanvasToDisplaySize(canvas3d, indices_render_objs, gl_context);
        await draw_scene();
    });
</script>

</html>