<!DOCTYPE html>

<html>

<head>
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <title>Gpx Editor</title>
    <style>
        html * {
            font-family: Arial, Helvetica, sans-serif;
            font-size: min(2vw, .5cm);
        }
        
        html, body {
            width: 100%;
            height: 100%;
            margin: 0px;
            overflow: hidden;
        }

        body {
            display: table;
        }

        a {
            cursor: pointer;
        }

        button {
            border: none;
            background-color: white;
            cursor: pointer;
        }

        .preview {
            height: 100%;
            width: 100%;
            background-color: black;
        }

        .fill {
            width: 100%;
            height: 100%;
        }
        
        #header, #content{
            display: table-row;
        }

        #header + #content{
            height: 100%;
        }
        
        #canvas3d {
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="header">
        {{#editor}}
        <center id="title">GPX Editor</center>
        <button id="save" onclick="save();">&#128190;</button>
        {{/editor}}
    </div>
    <div id="content">
        <div id="preview" class="preview">
            <canvas id="canvas3d" class="fill"></canvas>
        </div>
    </div>
</body>
<script type="text/javascript" src="{{&site_url}}/lin_alg.js"></script>
<script>
    const user_credentials = "{{credentials}}";
    const file_path = "{{&file_path}}";

    let canvas3d = document.getElementById("canvas3d");
    let canvas_drag_start = null;
    let camera_state = {};  // contains all camera state for rendering
    let gl_context = null;
    let render_3d_program = null;
    let camera_center = null;
    const cam_rot_speed = .001;
    const cam_dir_speed = .1;
    const up_dir = Vec4(0, 0, 1, 0);
    let camera_dir = 0;     // given in radians, 0 means dead north
    let camera_pitch = 0;   // given in radians, 0 means straight ahead, pi straight up -pi straight down
    let camera_perspective = null;
    let camera_orthographic = null;
    let camera_interpolation = 0; // interpolation value between orthographic and projection mapping (0 means full projection, 1 means full orthographic)
    let heightmap_meta_data = null;
    canvas3d.addEventListener("mousedown", (e) => { if (e.buttons == 1) canvas_drag_start = { x: e.clientX, y: e.clientY }; });
    canvas3d.addEventListener("mousemove", (event) => {
        if (canvas_drag_start) {
            let xDel = canvas_drag_start.x - event.clientX;
            let yDel = canvas_drag_start.y - event.clientY;
            camera_dir -= xDel * cam_rot_speed;
            if (camera_dir > 2 * Math.PI ) camera_dir -= 2 * Math.PI;
            if (camera_dir < 0)            camera_dir += 2 * Math.PI;
            camera_pitch += yDel * cam_rot_speed;
            if (camera_pitch > Math.PI / 2) camera_pitch = Math.PI / 2;
            if (camera_pitch < -Math.PI / 2) camera_pitch = -Math.PI / 2;
            draw_scene();
            canvas_drag_start = { x: event.clientX, y: event.clientY };
        }
    });
    canvas3d.addEventListener("mouseup", (e) => { canvas_drag_start = null; });
    canvas3d.addEventListener("mouseleave", (e) => { canvas_drag_start = null; });
    canvas3d.addEventListener("wheel", (e) => {
        draw_scene();
    });
    window.addEventListener("keydown", (e) => {
        if (document.querySelector(".preview:hover") == null)
            return;
        switch(e.key) {
        case "W":
        case "w": 
            camera_center.add(get_forward_dir(camera_dir, camera_pitch).mul(-cam_dir_speed));
            break;
        case "A":
        case "a": 
            camera_center.add(get_right_dir(-camera_dir).mul(-cam_dir_speed));
            break;
        case "S":
        case "s": 
            camera_center.add(get_forward_dir(camera_dir, camera_pitch).mul(cam_dir_speed));
            break;
        case "D":
        case "d": 
            camera_center.add(get_right_dir(-camera_dir).mul(cam_dir_speed));
            break;
        case "Q":
        case "q": 
            camera_center.add(up_dir.multiply(-cam_dir_speed));
            break;
        case "E":
        case "e":
            camera_center.add(up_dir.multiply(cam_dir_speed));
            break;
        default: return;
        }
        e.preventDefault();
        draw_scene();
    });

    // draws the scene with all loaded data
    async function draw_scene() {
        if (!gl_context)
            return;

        gl_context.viewport(0, 0, canvas3d.width, canvas3d.height);
        gl_context.clearColor(0, 0, 0, 1.0);
        gl_context.clearDepth(1.0);

        gl_context.clear(gl_context.COLOR_BUFFER_BIT | gl_context.DEPTH_BUFFER_BIT);

        // creating the view matrix -------------------------------------------
        console.log("Cam dir: " + String(camera_dir) + ", pitch: " + String(camera_pitch));
        let at = get_forward_dir(camera_dir, camera_pitch).to_absolute_vec();
        at.entries[2] += camera_center.z();
        const view = LookAt(Vec4(0, 0, camera_center.z(), 1), // camera_center is always in the center, the tiles a re moved relative to the camera center
                            at, 
                            up_dir);
        let view_projection = camera_perspective.morph(camera_orthographic, camera_interpolation);
        view_projection.mul(view);  // inplace multiplication which corresponds to Proj * View which means the view matrix is applied before the projection
        gl_context.useProgram(render_3d_program.program);
        console.log(camera_center.to_string());
        console.log(view.to_string());
        gl_context.uniformMatrix4fv(render_3d_program.uniform_locations.view_proj, false, view_projection.entries);

        // drawing the tiles --------------------------------------------------
        // grid jump for triangles is done all 10 meters
        let grid_offset_pos = get_detail_base_pos(Pos(camera_center.x(), camera_center.y()));
        let grid_offset_pos_rel = Pos(grid_offset_pos.lat - camera_center.x(), grid_offset_pos.lon - camera_center.y());
        // drawing the hq center triangles
        const base_width = 100; // base width of a detail tile given in meters
        gl_context.uniform1i(render_3d_program.uniform_locations.tile_width, base_width);
        gl_context.uniform1f(render_3d_program.uniform_locations.tile_width_m, base_width);
        gl_context.uniform2f(render_3d_program.uniform_locations.grid_offset_pos, grid_offset_pos.lat, grid_offset_pos.lon);
        gl_context.uniform2f(render_3d_program.uniform_locations.grid_offset_pos_rel, grid_offset_pos_rel.lat, grid_offset_pos_rel.lon);
        gl_context.drawArrays(gl_context.TRIANGLES, 0, 6 * base_width * base_width);

        // drawing the surrounding lower quality triangles
        const radius = 7;
        const triangle_resolution = 25;
        gl_context.uniform1i(render_3d_program.uniform_locations.tile_width, triangle_resolution);
        let cur_d = base_width;
        let cur_base_pos = Pos(grid_offset_pos.lat - cur_d, grid_offset_pos.lon - cur_d);
        const draw_patch = (cam, cur_base_pos, tile_width_m) => {
            const cur_base_pos_rel = Pos(cur_base_pos.lat - cam.x(), cur_base_pos.lon - cam.y());
            gl_context.uniform1f(render_3d_program.uniform_locations.tile_width_m, tile_width_m);
            gl_context.uniform2f(render_3d_program.uniform_locations.grid_offset_pos, cur_base_pos.lat, cur_base_pos.lon);
            gl_context.uniform2f(render_3d_program.uniform_locations.grid_offset_pos_rel, cur_base_pos_rel.lat, cur_base_pos_rel.lon);
            gl_context.drawArrays(gl_context.TRIANGLES, 0, 6 * triangle_resolution * triangle_resolution);
        };
        for (let i = 0; i < radius; ++i, cur_d *= 3, cur_base_pos.lat -= cur_d, cur_base_pos.lon -= cur_d) { // cur d has to be tripled as the block currently rendered has 3 * the cur_d width
            draw_patch(camera_center, cur_base_pos, cur_d);
            draw_patch(camera_center, Pos(cur_base_pos.lat + cur_d, cur_base_pos.lon), cur_d);
            draw_patch(camera_center, Pos(cur_base_pos.lat + 2 * cur_d, cur_base_pos.lon), cur_d);
            draw_patch(camera_center, Pos(cur_base_pos.lat, cur_base_pos.lon + cur_d), cur_d);
            draw_patch(camera_center, Pos(cur_base_pos.lat + 2 * cur_d, cur_base_pos.lon + cur_d), cur_d);
            draw_patch(camera_center, Pos(cur_base_pos.lat, cur_base_pos.lon + 2 * cur_d), cur_d);
            draw_patch(camera_center, Pos(cur_base_pos.lat + cur_d, cur_base_pos.lon + 2 * cur_d), cur_d);
            draw_patch(camera_center, Pos(cur_base_pos.lat + 2 * cur_d, cur_base_pos.lon + 2 * cur_d), cur_d);
        }
    }

    // ----------------------------------------------------------------------------------------
    // init section (contains also the shader code)
    // ----------------------------------------------------------------------------------------

    async function init() {
        // wegl init
        gl_context = canvas3d.getContext('webgl2') || canvas3d.getContext('experimental-webgl2');
        if (!gl_context) {
            alert('Unable to initialize WebGL. Your browser or machine ma not support it');
            return;
        }

        const vs = `#version 300 es
        precision highp float;

        uniform int tile_width;             // tile width in vertex count, always equals the tile height
        uniform float tile_width_m;         // tile width in meters, always equals the tile height
        uniform vec2 grid_offset_pos;
        uniform vec2 grid_offset_pos_rel;   // is the relative offset position which is relative to the viewer position
        uniform mat4 view_proj;

        // out variables
        out float vs_tid; // triangle index for coloring
        
        void main(void) {
            int quad_idx = gl_VertexID % 6 / 3;
            int triangle_idx = gl_VertexID % 3;
            int pos_off_x = gl_VertexID / 6 % tile_width;
            int pos_off_y = gl_VertexID / 6 / tile_width;
            int x_offset = int(triangle_idx == 1) ^ quad_idx;
            int y_offset = int(triangle_idx == 2) ^ quad_idx;
            float x = float(pos_off_x + x_offset) / float(tile_width) * tile_width_m;
            float y = float(pos_off_y + y_offset) / float(tile_width) * tile_width_m;
            vec4 pos_cam_rel = vec4(x, y, 0., 1.);
            pos_cam_rel.xy += grid_offset_pos_rel;

            gl_Position = view_proj * pos_cam_rel;
            vs_tid = float(gl_VertexID / 3);
        }
        `
        const fs = `#version 300 es
        precision highp float;
        in float vs_tid;

        out vec4 out_col; 
        void main(void) {
            out_col = vec4(sin(vs_tid * .134), sin(vs_tid * .143 + .3), sin(vs_tid * 0.143 + .67), 1.);
        }
        `
        const render_pipeline_3d = initShaderProgram(gl_context, vs, fs);
        render_3d_program = {
            program: render_pipeline_3d,
            uniform_locations: {
                tile_width: gl_context.getUniformLocation(render_pipeline_3d, 'tile_width'),
                tile_width_m: gl_context.getUniformLocation(render_pipeline_3d, 'tile_width_m'),
                grid_offset_pos: gl_context.getUniformLocation(render_pipeline_3d, 'grid_offset_pos'),
                grid_offset_pos_rel: gl_context.getUniformLocation(render_pipeline_3d, 'grid_offset_pos_rel'),
                view_proj: gl_context.getUniformLocation(render_pipeline_3d, 'view_proj'),
            }
        };
        
        let meta = await fetch(location.origin + "/heightmap/meta");
        heightmap_meta_data = await meta.json();
        
        camera_center = Vec4(5304500, 5305500, 300);

        linalg_tests();
    }
    init();

    const Pos = (lat, lon) => {
        return {
            lat: lat,
            lon: lon,
            to_string: function () { return '{' + String(this.lat) + ', ' + String(this.lon) + '}'; },
        }
    };

    const get_detail_base_pos = (pos) => {
        // as the tiles are always increasing by 1000, and we want a transfer of triangles
        // in 1/10th of the difference, we round the pos to multiple of 100 in each direction
        const divider = 100;
        return Pos(Math.floor(pos.lat / divider) * divider, Math.floor(pos.lon / divider) * divider);
    };

    // constructs the forward vector which also takes pitch into account (if looking down, the front vector should also go down
    const get_forward_dir = (dir, pitch) => { return Vec4(Math.sin(dir) * Math.cos(pitch), Math.cos(dir) * Math.cos(pitch), Math.sin(pitch), 0); };
    // constructs the right vector which is independent of the viewing pitch
    const get_right_dir = (dir) => { return Vec4(Math.cos(dir), Math.sin(dir), 0, 0); };

    // ----------------------------------------------------------------------------------------
    // The following two functions are from https://mdn.github.io/webgl-examples/tutorial/sample5/index.html
    // ----------------------------------------------------------------------------------------

    // init shader program.
    function initShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
        // Create the shader program
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        // If creating the shader program failed, alert
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
            return null;
        }
        return shaderProgram;
    }

    //
    // creates a shader of the given type, uploads the source and
    // compiles it.
    //
    function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        // Send the source to the shader object
        gl.shaderSource(shader, source);
        // Compile the shader program
        gl.compileShader(shader);
        // See if it compiled successfully
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function resizeCanvasToDisplaySize(canvas) {
        // Lookup the size the browser is displaying the canvas in CSS pixels.
        const displayWidth = canvas.clientWidth;
        const displayHeight = canvas.clientHeight;
        // Check if the canvas is not the same size.
        const needResize = canvas.width !== displayWidth ||
            canvas.height !== displayHeight;
        if (needResize) {
            // Make the canvas the same size
            canvas.width = displayWidth;
            canvas.height = displayHeight;
        }
        // create camera projection matrices
        camera_perspective = PerspectiveFov(90,  displayWidth / displayHeight, .1, 10000);
        const screen_size_factor = .01;
        camera_orthographic = Orthographic(displayHeight * screen_size_factor, displayWidth * screen_size_factor, .1, 10000);
        return needResize;
    }
    window.addEventListener("resize", () => {
        let height = String(document.documentElement.clientHeight  - document.getElementById("header").clientHeight) + "px";
        canvas3d.style.height = height;
        resizeCanvasToDisplaySize(canvas3d);
        draw_scene();
    });
    resizeCanvasToDisplaySize(canvas3d);

</script>

</html>